# railroad

## Homework for Thinknetica course (part 5) 

Задание:

 - Разбить программу на отдельные классы (каждый класс в отдельном файле)
 - Разделить поезда на два типа PassengerTrain и CargoTrain, сделать родителя для классов, который будет содержать общие методы и свойства
 - Определить, какие методы могут быть помещены в private/protected и вынести их в такую секцию. В комментарии к методу обосновать, почему он был вынесен в private/protected
 - Вагоны теперь делятся на грузовые и пассажирские (отдельные классы). К пассажирскому поезду можно прицепить только пассажирские, к грузовому - грузовые. 
 - При добавлении вагона к поезду, объект вагона должен передаваться как аргумент метода и сохраняться во внутреннем массиве поезда, в отличие от предыдущего задания, где мы считали только кол-во вагонов. Параметр конструктора "кол-во вагонов" при этом можно удалить.


Добавить текстовый интерфейс:

Создать программу в файле main.rb, которая будет позволять пользователю через текстовый интерфейс делать следующее:

  - Создавать станции
     
  - Создавать поезда
     
  - Создавать маршруты и управлять станциями в нем (добавлять, удалять)
     
  - Назначать маршрут поезду
     
  - Добавлять вагоны к поезду
     
  - Отцеплять вагоны от поезда
     
  - Перемещать поезд по маршруту вперед и назад
     
  - Просматривать список станций и список поездов на станции
  
  ## Homework for Thinknetica course (part 6) 
  
   Задание:
     
   - Создать модуль, который позволит указывать название компании-производителя и получать его. Подключить модуль к классам Вагон и Поезд
     
   - В классе Station (жд станция) создать метод класса all, который возвращает все станции (объекты), созданные на данный момент
  -  Добавить к поезду атрибут Номер (произвольная строка), если его еще нет, который указыватеся при его создании
В классе Train создать метод класса find, который принимает номер поезда (указанный при его создании) и возвращает объект поезда по номеру или nil, если поезд с таким номером не найден.

  - Создать модуль InstanceCounter, содержащий следующие методы класса и инстанс-методы, которые подключаются автоматически при вызове include в классе:

  Методы класса:
  
   - instances, который возвращает кол-во экземпляров данного класса
       
  Инастанс-методы:
  
   - register_instance, который увеличивает счетчик кол-ва экземпляров класса и который можно вызвать из конструктора. При этом данный метод не должен быть публичным.
       
Подключить этот модуль в классы поезда, маршрута и станции.

**Примечание:** инстансы подклассов могут считатья по отдельности, не увеличивая счетчик инстансов базового класса. 


 ## Homework for Thinknetica course (part 7)
 
 Задание к уроку

 - Реализовать проверку (валидацию) данных для всех классов. Проверять основные атрибуты (название, номер, тип и т.п.) на наличие, длину и т.п. (в зависимости от атрибута):

      - Валидация должна вызываться при создании объекта, если объект невалидный, то должно выбрасываться исключение
      - Должен быть метод valid? который возвращает true, если объект валидный и false - в противном случае.
      
- Релизовать проверку на формат номера поезда. Допустимый формат: три буквы или цифры в любом порядке, необязательный дефис (может быть, а может нет) и еще 2 буквы или цифры после дефиса.

- Убрать из классов все puts (кроме методов, которые и должны что-то выводить на экран), методы просто возвращают значения. *(Начинаем бороться за чистоту кода).*

- Релизовать простой текстовый интерфейс для создания поездов (если у вас уже реализован интерфейс, то дополнить его):

    - Программа запрашивает у пользователя данные для создания поезда (номер и другие необходимые атрибуты)
    - Если атрибуты валидные, то выводим информацию о том, что создан такой-то поезд
    - Если введенные данные невалидные, то программа должна вывести сообщение о возникших ошибках и заново запросить данные у пользователя. Реализовать это через механизм обработки исключений

В качестве ответа приложить ссылку на репозиторий с решением

 ## Homework for Thinknetica course (part 8)
 
 Задание к уроку

Для пассажирских вагонов:


- Добавить атрибут общего кол-ва мест (задается при создании вагона)

- Добавить метод, который "занимает места" в вагоне (по одному за раз)

- Добавить метод, который возвращает кол-во занятых мест в вагоне

- Добавить метод, возвращающий кол-во свободных мест в вагоне.



Для грузовых вагонов:


- Добавить атрибут общего объема (задается при создании вагона)

- Добавить метод, которые "занимает объем" в вагоне (объем указывается в качестве параметра метода)

- Добавить метод, который возвращает занятый объем

- Добавить метод, который возвращает оставшийся (доступный) объем



У класса Station:


- написать метод, который принимает блок и проходит по всем поездам на станции, передавая каждый поезд в блок.



У класса Train:


 - написать метод, который принимает блок и проходит по всем вагонам поезда (вагоны должны быть во внутреннем массиве), передавая каждый объект вагона в блок.



Если нет интерфейса, то в отдельном файле, например, main.rb написать код, который:


Создает тестовые данные (станции, поезда, вагоны) и связывает их между собой.

- Используя созданные в рамках задания методы, написать код, который перебирает последовательно все станции и для каждой станции выводит список поездов в формате:

   - Номер поезда, тип, кол-во вагонов
     
   А для каждого поезда на станции выводить список вагонов в формате:
   
   - Номер вагона (можно назначать автоматически), тип вагона, кол-во свободных и занятых мест (для пассажирского вагона) или кол-во свободного и занятого объема (для грузовых вагонов).

Если у вас есть интерфейс, то добавить возможности:


- При создании вагона указывать кол-во мест или общий объем, в зависимости от типа вагона

- Выводить список вагонов у поезда (в указанном выше формате), используя созданные методы

- Выводить список поездов на станции (в указанном выше формате), используя  созданные методы

- Занимать место или объем в вагоне


В качестве ответа приложить ссылку на репозиторий с решением

 ## Homework for Thinknetica course (part 9)
 
 Задание к уроку

- Просмотреть код своего проекта и попробовать применить рассмотренные идиомы там, где это возможно.
- Изучить Ruby Style Guide (ссылка в материалах к уроку). Рекомендую знакомиться с английским вариантом, а русский использовать только для непонятных мест. Английский вариант наиболее актуальный, кроме того, в русском есть неточности.
- Посмотреть мастер-класс "Почему код должен быть стильным" (ссылка в материалах к уроку)
Установить rubocop и проанализировать свой проект с его помощью
- Исправить все ошибки (кроме отсутствия документации), которые выдаст rubocop. То, что он не сможет исправить в автоматическом режиме, исправить вручную. Залить исправленные версии на гитхаб.


В качестве ответа приложить ссылку на репозиторий

 ## Homework for Thinknetica course (part 10)

Задание к уроку

Написать модуль Acсessors, содержащий следующие методы, которые можно вызывать на уровне класса:

  - метод   

`attr_accessor_with_history`
 
  Этот метод динамически создает геттеры и сеттеры для любого кол-ва атрибутов, при этом сеттер сохраняет все значения инстанс-переменной при изменении этого значения. 
Также в класс, в который подключается модуль должен добавляться инстанс-метод  

`<имя_атрибута>_history`

  который возвращает массив всех значений данной переменной.
  
 - метод  
`strong_attr_accessor`
 
 который принимает имя атрибута и его класс. При этом создается геттер и сеттер для одноименной инстанс-переменной, но сеттер проверяет тип присваемоего значения. Если тип отличается от того, который указан вторым параметром, то выбрасывается исключение. Если тип совпадает, то значение присваивается.

 Написать модуль Validation, который:

  - Содержит метод класса validate. Этот метод принимает в качестве параметров имя проверяемого атрибута, а также тип валидации и при необходимости дополнительные параметры.Возможные типы валидаций:
  
  
   -presence - требует, чтобы значение атрибута было не nil и не пустой строкой. 
    Пример использования:
    
   `validate :name, :presence`
   
   -format (при этом отдельным параметром задается регулярное выражение для формата). 
   Треубет соответствия значения атрибута заданному регулярному выражению. Пример:
   
  `validate :number, :format, /A-Z{0,3}/`
   
   -type (третий параметр - класс атрибута). Требует соответствия значения атрибута заданному классу. Пример:
   
   `validate :station, :type, RailwayStation`
 
 - Содержит инстанс-метод validate!, который запускает все проверки (валидации), указанные в классе через метод класса validate. В случае ошибки валидации выбрасывает исключение с сообщением о том, какая именно валидация не прошла
 - Содержит инстанс-метод valid? который возвращает true, если все проверки валидации прошли успешно и false, если есть ошибки валидации.

К любому атрибуту можно применить несколько разных валидаторов, например

`validate :name, :presence`

`validate :name, :format, /A-Z/`

`validate :name, :type, String`

Все указанные валидаторы должны применяться к атрибуту

Допустимо, что модуль не будет работать с наследниками.

Подключить эти модули в свои классы и продемонстрировать их использование. Валидации заменить на методы из модуля Validation. 

В качестве ответа приложить ссылку на репозиторий с решением
